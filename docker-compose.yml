version: "3.9"

networks:
  backend-net:
    name: backend-net
    driver: bridge
  frontend-net:
    name: frontend-net
    driver: bridge

volumes:
  zkdata: {}
  kafka-logs: {}
  pgdata: {}
  checkpoint: {}

services:
  zookeeper:
    image: bitnami/zookeeper:3.9
    container_name: zookeeper
    networks: [backend-net]
    volumes:
      - zkdata:/bitnami/zookeeper
    environment:
      ALLOW_ANONYMOUS_LOGIN: "yes"
    ports: ["2181:2181"]

  kafka:
    build: ./Infra/kafka
    container_name: kafka
    depends_on: [zookeeper]
    networks: [backend-net]
    volumes:
      - kafka-logs:/tmp/kafka-logs
    ports: ["9092:9092"]
    environment:
      KAFKA_HEAP_OPTS: "-Xmx1g"

  postgres:
    image: postgres:15                         # Utilise l'image officielle PostgreSQL version 15
    container_name: postgres                   # Nom explicite pour le conteneur (facilite les commandes docker)
    
    networks:
      - backend-net                            # Le conteneur appartient à deux réseaux :
      - frontend-net                           # Cela permet à plusieurs services (par exemple Streamlit & Kafka) d'y accéder
    
    volumes:
      - pgdata:/var/lib/postgresql/data        # Volume pour persister les données (même après arrêt du conteneur)
      - ./Infra/postgres/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
                                               # Script SQL de création/initialisation exécuté au 1er lancement
                                               # ":ro" signifie "read-only" (sécurisé)
    
    environment:
      POSTGRES_DB: openfood                    # Nom de la base de données à créer au démarrage
      POSTGRES_USER: ingest                    # Nom d'utilisateur PostgreSQL
      POSTGRES_PASSWORD: ingestpwd             # Mot de passe de l'utilisateur
    
    ports:
      - "5433:5432"                            # Mappe le port 5432 du conteneur (par défaut PostgreSQL)
                                               # vers le port 5433 de ta machine hôte (évite conflit local)


  producer:
    build:
      context: .
      dockerfile: src/main/scala/com/esgi/Producer/Dockerfile
    container_name: producer
    depends_on: [kafka]
    networks: [backend-net]
    environment:
      KAFKA_BOOTSTRAP_SERVERS: kafka:9092
      USE_API: "true"
      BATCH_LENGTH: "100"
      MAX_OFFSET: "3808300"
    volumes:
      - ./data:/app/data

  consumer:
    build:
      context: .
      dockerfile: src/main/scala/com/esgi/Consumer/Dockerfile
    container_name: consumer
    depends_on: [kafka, postgres]
    networks: [backend-net]
    environment:
      KAFKA_BOOTSTRAP_SERVERS: kafka:9092
      CHECKPOINT_PATH: /checkpoint/generic
      PG_URL: jdbc:postgresql://postgres:5432/openfood
      PG_USER: ingest
      PG_PWD: ingestpwd
    volumes:
      - checkpoint:/checkpoint

  streamlit:
    build:
      context: ./streamlit # Dossier source contenant le Dockerfile et les fichiers à copier
      dockerfile: Dockerfile  # Nom du Dockerfile utilisé (dans ./streamlit)
    container_name: streamlit # Nom explicite du conteneur (évite un nom auto-généré)
    depends_on: [postgres]  #Attend que le conteneur PostgreSQL soit lancé avant de démarrer
    networks: [frontend-net]  # Le conteneur est connecté au réseau nommé `frontend-net`
    ports:
      - "8501:8501"
